/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package de.mgrimpo.adventofcode.year2019.days;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.HashSet;
import java.util.List;
import java.util.Objects;
import java.util.Set;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

public class Day3 {

  private static final Coordinate CENTRAL_PORT = new Coordinate(0, 0);

  public static Set<Coordinate> parseWireDescription(String wireDescription) {
    var wireInstructions = wireDescription.split(",");
    Coordinate currentCoordinate = CENTRAL_PORT;
    var wireCoordinates = new HashSet<Coordinate>();
    wireCoordinates.add(currentCoordinate);
    for (var wireInstruction : wireInstructions) {
      currentCoordinate = parseWireInstruction(currentCoordinate, wireCoordinates, wireInstruction);
    }
    return wireCoordinates;
  }

  private static Coordinate parseWireInstruction(
      Coordinate currentCoordinate, Set<Coordinate> wireCoordinates, String wireInstruction) {
    if (wireInstruction.length() < 2) {
      throw new RuntimeException(
          String.format(
              "Invalid wire description, illegal instruction '%s' occurred", wireInstruction));
    }
    var direction = wireInstruction.charAt(0);
    var distance = Integer.parseInt(wireInstruction.substring(1));
    switch (direction) {
      case 'U':
        wireCoordinates.addAll(currentCoordinate.lineUp(distance));
        currentCoordinate = currentCoordinate.up(distance);
        break;
      case 'D':
        wireCoordinates.addAll(currentCoordinate.lineDown(distance));
        currentCoordinate = currentCoordinate.down(distance);
        break;
      case 'L':
        wireCoordinates.addAll(currentCoordinate.lineLeft(distance));
        currentCoordinate = currentCoordinate.left(distance);
        break;
      case 'R':
        wireCoordinates.addAll(currentCoordinate.lineRight(distance));
        currentCoordinate = currentCoordinate.right(distance);
        break;
      default:
        throw new RuntimeException(
            String.format(
                "Invalid wire description, illegal instruction '%s' occurred", wireInstruction));
    }
    return currentCoordinate;
  }

  public static Set<Coordinate> wireIntersectionPoints(
      String wireOneDescription, String wireTwoDescription) {
    var wireOne = parseWireDescription(wireOneDescription);
    var wireTwo = parseWireDescription(wireTwoDescription);
    wireOne.retainAll(wireTwo);
    wireOne.remove(CENTRAL_PORT);
    return wireOne;
  }

  public static int fewesteCombinedStepsToIntersection(
      String wireOneDescription, String wireTwoDescription) {
    var intersectionPoints = wireIntersectionPoints(wireOneDescription, wireTwoDescription);
    if (intersectionPoints.isEmpty()) throw new RuntimeException("Wires have no intersection points!");
    return intersectionPoints.stream()
        .mapToInt(
            intersectionPoint ->
                stepsToCoordinate(wireOneDescription, intersectionPoint)
                    + stepsToCoordinate(wireTwoDescription, intersectionPoint))
        .min()
        .getAsInt();
  }

  public static int stepsToCoordinate(String wireDescription, Coordinate destinationCoordinate) {
    var currentCoordinate = CENTRAL_PORT;
    var visitedCoordinates = new HashSet<Coordinate>();
    visitedCoordinates.add(CENTRAL_PORT);
    var steps = 0;
    for (var wireInstruction : wireDescription.split(",")) {
      var oldCoordinate = currentCoordinate;
      currentCoordinate =
          parseWireInstruction(currentCoordinate, visitedCoordinates, wireInstruction);
      if (visitedCoordinates.contains(destinationCoordinate)) {
        steps += oldCoordinate.manhattanDistance(destinationCoordinate);
        break;
      }
      steps += oldCoordinate.manhattanDistance(currentCoordinate);
    }
    return steps;
  }

  public static int shortestDistanceToCentralPort(
      String wireOneDescription, String wireTwoDescription) {
    var intersectionPoints = wireIntersectionPoints(wireOneDescription, wireTwoDescription);
    if (intersectionPoints.isEmpty()) throw new RuntimeException("Wires have no intersection points!");
    var closestIntersection =
        intersectionPoints.stream()
            .reduce(
                (a, b) ->
                    a.manhattanDistance(CENTRAL_PORT) < b.manhattanDistance(CENTRAL_PORT) ? a : b)
            .get();
    return closestIntersection.manhattanDistance(CENTRAL_PORT);
  }

  public static void main(String[] args) throws IOException {
    var puzzleInput = readPuzzleInput();
    puzzleOne(puzzleInput);
    puzzleTwo(puzzleInput);
  }

  private static void puzzleTwo(List<String> puzzleInput) {
    System.out.println("Day 3 : Puzzle 1");
    var puzzleTwoSolution =
        fewesteCombinedStepsToIntersection(puzzleInput.get(0), puzzleInput.get(1));
    System.out.printf(
        "The fewest combined steps to an intersection of the wires are: %s\n", puzzleTwoSolution);
  }

  private static void puzzleOne(List<String> puzzleInput) {
    System.out.println("Day 3 : Puzzle 2");
    var puzzleOneSolution = shortestDistanceToCentralPort(puzzleInput.get(0), puzzleInput.get(1));
    System.out.printf(
        "The shortest distance from an intersection point of the two wires to the central port is: %s\n",
        puzzleOneSolution);
  }

  private static List<String> readPuzzleInput() throws IOException {
    return Files.readAllLines(Path.of("input/day3_input.txt"));
  }

  static class Coordinate {
    public final int x;
    public final int y;

    Coordinate(int x, int y) {
      this.x = x;
      this.y = y;
    }

    public int manhattanDistance(Coordinate other) {
      return Math.abs(this.x - other.x) + Math.abs(this.y - other.y);
    }

    @Override
    public boolean equals(Object o) {
      if (this == o) {
        return true;
      }
      if (o == null || getClass() != o.getClass()) {
        return false;
      }
      Coordinate that = (Coordinate) o;
      return x == that.x && y == that.y;
    }

    @Override
    public int hashCode() {
      return Objects.hash(x, y);
    }

    public Set<Coordinate> lineUp(int distance) {
      return IntStream.rangeClosed(0, distance).mapToObj(this::up).collect(Collectors.toSet());
    }

    public Coordinate up(int distance) {
      return new Coordinate(this.x, y + distance);
    }

    public Set<Coordinate> lineDown(int distance) {
      return IntStream.rangeClosed(0, distance).mapToObj(this::down).collect(Collectors.toSet());
    }

    public Coordinate down(int distance) {
      return new Coordinate(this.x, y - distance);
    }

    public Set<Coordinate> lineRight(int distance) {
      return IntStream.rangeClosed(0, distance).mapToObj(this::right).collect(Collectors.toSet());
    }

    public Coordinate right(int distance) {
      return new Coordinate(this.x + distance, y);
    }

    public Set<Coordinate> lineLeft(int distance) {
      return IntStream.rangeClosed(0, distance).mapToObj(this::left).collect(Collectors.toSet());
    }

    public Coordinate left(int distance) {
      return new Coordinate(this.x - distance, y);
    }

    @Override
    public String toString() {
      return "Coordinate{" + "x=" + x + ", y=" + y + '}';
    }
  }
}
